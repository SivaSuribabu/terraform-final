You’re thinking correctly about cost control (10-hour UAT), but if you recreate everything daily, you’ll introduce:

DNS propagation delays

Beanstalk environment stabilization time (10–20 mins)

Load balancer re-provisioning delays

Drift + pipeline instability

Developer friction

So the right approach is:

Keep network + identity static.
Make compute ephemeral.

1️⃣ What MUST Be Static (Create Once)

These resources should never be destroyed daily.

Network Layer (Static Foundation)

VPC

Private subnets (min 2 AZs)

Public subnets (only if NAT needed)

NAT Gateway (if private instances need internet)

Route tables

Internet Gateway (if NAT used)

These are slow + expensive to recreate and cause route propagation delays.

Security & Identity (Static)

Security Groups

IAM Roles

Beanstalk service role

EC2 instance profile role

KMS keys (if used)

S3 artifact bucket (for Beanstalk versions)

Destroying these daily causes dependency chaos.

Internal DNS (Static)

Route53 Private Hosted Zone

UAT internal record (ALIAS → ALB)

Example:

uat.internal.company.local

Don’t recreate this daily — DNS caching will hurt you.

2️⃣ What Should Be Ephemeral (10 Hours Only)

Only these should be created/destroyed daily:

Elastic Beanstalk Application

Elastic Beanstalk Environment

Auto Scaling Group

EC2 instances

Internal ALB (created by Beanstalk)

Target Groups

When you terminate the environment → everything above goes.

3️⃣ Target Architecture (Internal Only)

Here is the full internal-only flow:

                 Developers (VPN / Direct Connect)
                           |
                           |
                    Route53 Private Hosted Zone
                           |
                           |
                 Internal ALB (Scheme = internal)
                           |
                           |
                  Beanstalk Auto Scaling Group
                           |
                           |
                    EC2 in Private Subnets
                           |
                           |
                        RDS (private)
4️⃣ Visual Architecture
4
5️⃣ Terraform Modular Structure (Enterprise Grade)

You need layered modules.

terraform/
│
├── modules/
│   ├── vpc/
│   ├── security-groups/
│   ├── iam/
│   ├── route53-private/
│   ├── beanstalk-app/
│   ├── beanstalk-env/
│
├── environments/
│   ├── uat/
│       ├── main.tf
│       ├── variables.tf
│       ├── backend.tf
│
└── shared/
    ├── locals.tf
6️⃣ Implementation Flow (Step-by-Step)
Phase 1 — One-Time Setup (Static Layer)
Step 1: Create VPC module

2 private subnets

NAT Gateway

Route tables

Outputs:

vpc_id

private_subnet_ids

Step 2: Security Groups

ALB SG

Allow 80/443 from VPN CIDR only

EC2 SG

Allow 8080 from ALB SG only

No public ingress. Zero 0.0.0.0/0.

Step 3: IAM

aws-elasticbeanstalk-service-role

ec2-instance-profile role

Step 4: Private Route53 Zone

Example:

uat.internal.devopswithsiva.in

Associate with VPC.

Phase 2 — Ephemeral Layer (Daily 10 Hours)
Step 5: Beanstalk Application

Static logical container.

Step 6: Beanstalk Environment

Critical settings:

EnvironmentType = LoadBalanced
LoadBalancerType = application
LoadBalancerIsShared = false
ELBScheme = internal
Subnets = private subnets

In Terraform:

setting {
  namespace = "aws:ec2:vpc"
  name      = "VPCId"
}

setting {
  namespace = "aws:ec2:vpc"
  name      = "Subnets"
}

setting {
  namespace = "aws:elb:loadbalancer"
  name      = "Scheme"
  value     = "internal"
}
Step 7: Route53 Alias Record

Alias to:

data.aws_lb.beanstalk_alb.dns_name
7️⃣ How to Auto Destroy After 10 Hours

You have 3 clean options:

Option A — Jenkins Scheduled Pipeline (Best for You)

Since you're already working with Jenkins + Terraform:

Pipeline:

terraform apply

Sleep 10 hours

terraform destroy

Better:

Use AWS EventBridge + Lambda instead of sleep.

Option B — EventBridge + Lambda Auto Destroy

Flow:

EventBridge rule (cron)
        ↓
Lambda
        ↓
terraform destroy (via SSM or container)

More production grade.

Option C — Scale to Zero (Better Than Destroy)

Instead of destroying:

Set ASG min=0 max=0 after 10 hours.

Keep environment alive.

No recreation delays next day.

This is usually smarter.

You're over-optimizing destruction. Compute is cheap. Re-creation cost in engineering time is not.

8️⃣ Cost Reality Check

Internal ALB = billed hourly
NAT Gateway = billed hourly (big cost driver)

If UAT is internal only:

Do you even need NAT?

If your app doesn't pull from internet → remove NAT.

That alone saves major cost.

9️⃣ Final Recommended Design (Balanced)

✔ Keep VPC + SG + IAM + Route53 static
✔ Keep Beanstalk Application static
✔ Only destroy Beanstalk Environment
✔ Or scale ASG to zero instead of destroy

10️⃣ Complete End-to-End Flow Summary
Developer
   ↓
Private DNS
   ↓
Internal ALB
   ↓
ASG
   ↓
EC2 (Private)
   ↓
Database (Private)

Terraform Flow:

terraform apply (static stack)
terraform apply (uat env stack)
10 hours
terraform destroy (uat env only)
11️⃣ Hard Questions You Must Answer

Why Beanstalk instead of ECS if you already use ECS heavily?

Why destroy instead of scale-to-zero?

Why NAT if fully internal?

Is UAT traffic heavy enough to justify ALB?

If this is internal-only and light traffic, a single instance environment may be enough.
